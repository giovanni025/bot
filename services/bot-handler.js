const axios = require('axios');
const database = require('../database/setup');
const telegramAdmin = require('./telegram-admin');
const moment = require('moment');

class IPTVBot {
  constructor() {
    // Configura√ß√µes b√°sicas
    this.evolutionApiUrl = process.env.EVOLUTION_API_URL || 'http://localhost:8080';
    this.evolutionApiKey = process.env.EVOLUTION_API_KEY;
    this.instanceName = process.env.INSTANCE_NAME || 'default';
    
    // Estados poss√≠veis do usu√°rio
    this.USER_STATES = {
      MENU_PRINCIPAL: 'menu_principal',
      TESTE_NOME: 'teste_nome', 
      TESTE_CIDADE: 'teste_cidade',
      TESTE_DISPOSITIVO: 'teste_dispositivo',
      PLANO_ESCOLHA: 'plano_escolha',
      PLANO_COMPROVANTE: 'plano_comprovante',
      RENOVACAO_LOGIN: 'renovacao_login',
      RENOVACAO_PLANO: 'renovacao_plano',
      RENOVACAO_COMPROVANTE: 'renovacao_comprovante',
      SUPORTE_PROBLEMA: 'suporte_problema',
      AGUARDANDO_ATENDENTE: 'aguardando_atendente'
    };
    
    // Cache tempor√°rio para dados do usu√°rio durante o fluxo
    this.userTempData = new Map();
    
    console.log('ü§ñ IPTV Bot inicializado com fluxo avan√ßado');
  }

  /**
   * Fun√ß√£o principal - processa mensagens recebidas
   */
  async handleIncomingMessage(phone, message, metadata = {}) {
    try {
      console.log(`üì® Mensagem de ${phone}: ${message}`);
      
      // Buscar ou criar usu√°rio
      let user = await this.getOrCreateUser(phone);
      
      // Log da mensagem
      await this.logMessage(user.id, phone, message, 'received');
      
      let response = '';

      // Primeira intera√ß√£o - enviar menu
      if (user.message_count === 0) {
        response = this.getWelcomeMessage();
        user.current_state = this.USER_STATES.MENU_PRINCIPAL;
        await telegramAdmin.notifyNewUser(phone, user.name || 'N√£o informado');
      } else {
        // Processar mensagem baseada no estado atual
        response = await this.processMessageByState(message, user);
      }

      // Atualizar usu√°rio
      await this.updateUserInteraction(user.id, user.current_state);

      // Enviar resposta
      if (response) {
        await this.sendMessage(phone, response, metadata.instance);
        await this.logMessage(user.id, phone, response, 'sent');
      }

    } catch (error) {
      console.error('‚ùå Erro:', error);
      await this.sendMessage(phone, '‚ùå Erro interno. Tente novamente ou digite MENU.', metadata.instance);
    }
  }

  /**
   * Processa mensagem baseada no estado atual do usu√°rio
   */
  async processMessageByState(message, user) {
    const msg = message.toLowerCase().trim();
    
    switch (user.current_state) {
      case this.USER_STATES.MENU_PRINCIPAL:
        return await this.handleMainMenu(msg, user);
        
      case this.USER_STATES.TESTE_NOME:
        return await this.handleTestName(message, user);
        
      case this.USER_STATES.TESTE_CIDADE:
        return await this.handleTestCity(message, user);
        
      case this.USER_STATES.TESTE_DISPOSITIVO:
        return await this.handleTestDevice(message, user);
        
      case this.USER_STATES.PLANO_ESCOLHA:
        return await this.handlePlanChoice(message, user);
        
      case this.USER_STATES.PLANO_COMPROVANTE:
        return await this.handlePlanPaymentProof(message, user);
        
      case this.USER_STATES.RENOVACAO_LOGIN:
        return await this.handleRenewalLogin(message, user);
        
      case this.USER_STATES.RENOVACAO_PLANO:
        return await this.handleRenewalPlan(message, user);
        
      case this.USER_STATES.RENOVACAO_COMPROVANTE:
        return await this.handleRenewalPaymentProof(message, user);
        
      case this.USER_STATES.SUPORTE_PROBLEMA:
        return await this.handleSupportProblem(message, user);
        
      case this.USER_STATES.AGUARDANDO_ATENDENTE:
        return await this.handleWaitingHuman(message, user);
        
      default:
        // Voltar ao menu principal se estado inv√°lido
        user.current_state = this.USER_STATES.MENU_PRINCIPAL;
        return this.getWelcomeMessage();
    }
  }

  /**
   * Gerencia menu principal
   */
  async handleMainMenu(msg, user) {
    // Reset para menu sempre que necess√°rio
    if (msg === 'menu' || msg === 'voltar' || msg === '0') {
      user.current_state = this.USER_STATES.MENU_PRINCIPAL;
      return this.getWelcomeMessage();
    }

    if (msg === '1' || msg.includes('teste')) {
      user.current_state = this.USER_STATES.TESTE_NOME;
      this.initTempData(user.phone);
      return this.handleTestRequest();
    }
    
    if (msg === '2' || msg.includes('plano')) {
      user.current_state = this.USER_STATES.PLANO_ESCOLHA;
      return await this.showPlans();
    }
    
    if (msg === '3' || msg.includes('renovar')) {
      user.current_state = this.USER_STATES.RENOVACAO_LOGIN;
      this.initTempData(user.phone);
      return this.handleRenewal();
    }
    
    if (msg === '4' || msg.includes('suporte')) {
      user.current_state = this.USER_STATES.SUPORTE_PROBLEMA;
      return this.handleSupport();
    }
    
    if (msg === '5' || msg.includes('atendente')) {
      user.current_state = this.USER_STATES.AGUARDANDO_ATENDENTE;
      await telegramAdmin.notifyHumanRequest(user.phone, 'Usu√°rio solicitou atendente');
      return this.handleHuman();
    }

    return `‚ùå Op√ß√£o n√£o reconhecida.\n\n${this.getWelcomeMessage()}`;
  }

  /**
   * Fluxo do teste gr√°tis - Dispositivo (finaliza√ß√£o)
   */
  async handleTestDevice(message, user) {
    const msg = message.toLowerCase().trim();
    
    if (msg === 'menu' || msg === 'voltar') {
      user.current_state = this.USER_STATES.MENU_PRINCIPAL;
      this.clearTempData(user.phone);
      return this.getWelcomeMessage();
    }
    
    let dispositivo = '';
    
    if (msg === '1' || msg.includes('android') || msg.includes('celular android')) {
      dispositivo = 'Android';
    } else if (msg === '2' || msg.includes('iphone') || msg.includes('ios') || msg.includes('apple')) {
      dispositivo = 'iPhone';
    } else if (msg === '3' || msg.includes('smart tv') || msg.includes('samsung') || msg.includes('lg')) {
      dispositivo = 'Smart TV';
    } else if (msg === '4' || msg.includes('tv box') || msg.includes('box')) {
      dispositivo = 'TV Box';
    } else if (msg === '5' || msg.includes('computador') || msg.includes('pc') || msg.includes('notebook')) {
      dispositivo = 'Computador';
    } else if (msg === '6' || msg.includes('outro')) {
      dispositivo = message.trim();
    } else {
      dispositivo = message.trim();
    }
    
    // Pegar dados tempor√°rios
    const tempData = this.getTempData(user.phone);
    const name = tempData.name || user.name || 'N√£o informado';
    const city = tempData.city || user.city || 'N√£o informada';
    
    // Atualizar dispositivo no banco
    await database.run('UPDATE users SET device = ? WHERE id = ?', [dispositivo, user.id]);
    
    // Criar solicita√ß√£o de teste pendente
    const testResult = await database.run(
      'INSERT INTO free_tests (user_id, name, city, device, status) VALUES (?, ?, ?, ?, ?)',
      [user.id, name, city, dispositivo, 'pending']
    );
    
    user.current_state = this.USER_STATES.MENU_PRINCIPAL;
    this.clearTempData(user.phone);
    
    // Notificar admin para aprova√ß√£o do teste
    await telegramAdmin.notifyTestRequest(user.phone, name, city, dispositivo, testResult.id);
    
    return `üéØ *SOLICITA√á√ÉO DE TESTE ENVIADA!*

üë§ *Nome:* ${name}
üìç *Cidade:* ${city}  
üì± *Dispositivo:* ${dispositivo}

‚è≥ *Aguarde a aprova√ß√£o*
Sua solicita√ß√£o foi enviada para nossa equipe. Voc√™ receber√° as credenciais de acesso em at√© 10 minutos.

üì≤ *Enquanto isso, baixe o aplicativo:*
‚Ä¢ üì± Android: IPTV Smarters Pro
‚Ä¢ üçé iPhone: GSE Smart IPTV
‚Ä¢ üì∫ Smart TV: Smart IPTV
‚Ä¢ üíª PC: VLC Player

üè† Digite *MENU* para voltar ao in√≠cio`;
  }

  /**
   * Escolha de planos (modificado para solicitar comprovante)
   */
  async handlePlanChoice(message, user) {
    const msg = message.toLowerCase().trim();
    
    if (msg.includes('menu') || msg === 'voltar' || msg === '0') {
      user.current_state = this.USER_STATES.MENU_PRINCIPAL;
      return this.getWelcomeMessage();
    }
    
    const settings = await this.getSettings();
    let selectedPlan = '';
    let price = '';
    let duration = '';
    
    if (msg.includes('mensal') || msg === '1') {
      selectedPlan = 'Mensal';
      price = settings.monthly_plan_price;
      duration = '1 m√™s';
    } else if (msg.includes('trimestral') || msg === '2') {
      selectedPlan = 'Trimestral';
      price = settings.quarterly_plan_price;
      duration = '3 meses';
    } else if (msg.includes('semestral') || msg === '3') {
      selectedPlan = 'Semestral';
      price = settings.semiannual_plan_price;
      duration = '6 meses';
    } else if (msg.includes('anual') || msg === '4') {
      selectedPlan = 'Anual';
      price = settings.annual_plan_price;
      duration = '12 meses';
    }
    
    if (selectedPlan) {
      // Salvar plano escolhido e solicitar comprovante
      this.setTempData(user.phone, 'selectedPlan', selectedPlan);
      this.setTempData(user.phone, 'planPrice', price);
      this.setTempData(user.phone, 'planDuration', duration);
      
      user.current_state = this.USER_STATES.PLANO_COMPROVANTE;
      
      return this.generatePlanPaymentData(selectedPlan, price, duration, settings);
    }
    
    return `‚ùå Plano n√£o reconhecido.\n\nDigite:\n‚Ä¢ *1* para Mensal (R$ ${settings.monthly_plan_price})\n‚Ä¢ *2* para Trimestral (R$ ${settings.quarterly_plan_price})\n‚Ä¢ *3* para Semestral (R$ ${settings.semiannual_plan_price})\n‚Ä¢ *4* para Anual (R$ ${settings.annual_plan_price})\n\nOu *MENU* para voltar`;
  }

  /**
   * Recebimento de comprovante de pagamento do plano
   */
  async handlePlanPaymentProof(message, user) {
    const msg = message.toLowerCase().trim();
    
    if (msg === 'menu' || msg === 'voltar') {
      user.current_state = this.USER_STATES.MENU_PRINCIPAL;
      this.clearTempData(user.phone);
      return this.getWelcomeMessage();
    }
    
    // Pegar dados tempor√°rios
    const tempData = this.getTempData(user.phone);
    const selectedPlan = tempData.selectedPlan;
    const planPrice = tempData.planPrice;
    const planDuration = tempData.planDuration;
    
    // Criar assinatura pendente
    const subResult = await database.run(
      'INSERT INTO subscriptions (user_id, plan, price, status) VALUES (?, ?, ?, ?)',
      [user.id, selectedPlan, parseFloat(planPrice), 'pending']
    );
    
    // Registrar comprovante
    await database.run(
      'INSERT INTO payment_proofs (user_id, phone, request_type, request_id, proof_data) VALUES (?, ?, ?, ?, ?)',
      [user.id, user.phone, 'subscription', subResult.id, message]
    );
    
    user.current_state = this.USER_STATES.MENU_PRINCIPAL;
    this.clearTempData(user.phone);
    
    // Notificar admin
    await telegramAdmin.notifyPlanPayment(user.phone, selectedPlan, planPrice, message, subResult.id);
    
    return `‚úÖ *COMPROVANTE RECEBIDO!*

üì¶ *Plano:* ${selectedPlan} (${planDuration})
üí∞ *Valor:* R$ ${planPrice}

‚è≥ *Status:* Aguardando aprova√ß√£o
üìã *Comprovante:* Registrado com sucesso

üîÑ *Pr√≥ximos passos:*
1Ô∏è‚É£ Nossa equipe analisar√° seu pagamento
2Ô∏è‚É£ Voc√™ receber√° login e senha em at√© 30 minutos
3Ô∏è‚É£ Comece a assistir imediatamente!

üì± *Importante:* Mantenha este n√∫mero ativo para receber suas credenciais.

üè† Digite *MENU* para voltar ao in√≠cio`;
  }

  /**
   * Renova√ß√£o - Plano (modificado para solicitar comprovante)
   */
  async handleRenewalPlan(message, user) {
    const msg = message.toLowerCase().trim();
    
    if (msg === 'menu' || msg === 'voltar') {
      user.current_state = this.USER_STATES.MENU_PRINCIPAL;
      this.clearTempData(user.phone);
      return this.getWelcomeMessage();
    }
    
    const settings = await this.getSettings();
    let plano = '';
    let valor = '';
    let duracao = '';
    
    if (msg === '1' || msg.includes('mensal')) {
      plano = 'Mensal';
      valor = settings.monthly_plan_price;
      duracao = '1 m√™s';
    } else if (msg === '2' || msg.includes('trimestral')) {
      plano = 'Trimestral';
      valor = settings.quarterly_plan_price;
      duracao = '3 meses';
    } else if (msg === '3' || msg.includes('semestral')) {
      plano = 'Semestral';
      valor = settings.semiannual_plan_price;
      duracao = '6 meses';
    } else if (msg === '4' || msg.includes('anual')) {
      plano = 'Anual';
      valor = settings.annual_plan_price;
      duracao = '12 meses';
    }
    
    if (plano) {
      // Salvar dados da renova√ß√£o
      this.setTempData(user.phone, 'renewalPlan', plano);
      this.setTempData(user.phone, 'renewalPrice', valor);
      this.setTempData(user.phone, 'renewalDuration', duracao);
      
      user.current_state = this.USER_STATES.RENOVACAO_COMPROVANTE;
      
      return this.generateRenewalPaymentData(plano, valor, duracao, settings);
    }
    
    return `‚ùå Op√ß√£o inv√°lida. Digite:\n‚Ä¢ *1* para Mensal\n‚Ä¢ *2* para Trimestral\n‚Ä¢ *3* para Semestral\n‚Ä¢ *4* para Anual\n\nOu *MENU* para voltar`;
  }

  /**
   * Recebimento de comprovante de renova√ß√£o
   */
  async handleRenewalPaymentProof(message, user) {
    const msg = message.toLowerCase().trim();
    
    if (msg === 'menu' || msg === 'voltar') {
      user.current_state = this.USER_STATES.MENU_PRINCIPAL;
      this.clearTempData(user.phone);
      return this.getWelcomeMessage();
    }
    
    // Pegar dados tempor√°rios
    const tempData = this.getTempData(user.phone);
    const renewalLogin = tempData.renewalLogin;
    const renewalPlan = tempData.renewalPlan;
    const renewalPrice = tempData.renewalPrice;
    const renewalDuration = tempData.renewalDuration;
    
    // Criar renova√ß√£o pendente
    const renewalResult = await database.run(
      'INSERT INTO renewals (user_id, current_login, plan, price, status, payment_proof) VALUES (?, ?, ?, ?, ?, ?)',
      [user.id, renewalLogin, renewalPlan, parseFloat(renewalPrice), 'pending', message]
    );
    
    user.current_state = this.USER_STATES.MENU_PRINCIPAL;
    this.clearTempData(user.phone);
    
    // Notificar admin
    await telegramAdmin.notifyRenewalPayment(user.phone, renewalLogin, renewalPlan, renewalPrice, message, renewalResult.id);
    
    return `‚úÖ *RENOVA√á√ÉO SOLICITADA!*

üë§ *Login atual:* ${renewalLogin}
üìÖ *Novo plano:* ${renewalPlan} (${renewalDuration})
üí∞ *Valor:* R$ ${renewalPrice}

‚è≥ *Status:* Aguardando aprova√ß√£o
üìã *Comprovante:* Registrado com sucesso

üîÑ *Pr√≥ximos passos:*
1Ô∏è‚É£ Nossa equipe analisar√° seu pagamento
2Ô∏è‚É£ Sua conta ser√° renovada em at√© 30 minutos
3Ô∏è‚É£ Continue assistindo sem interrup√ß√£o!

üì± *Importante:* Voc√™ ser√° notificado quando a renova√ß√£o for aprovada.

üè† Digite *MENU* para voltar ao in√≠cio`;
  }

  /**
   * Gerar dados de pagamento para planos
   */
  generatePlanPaymentData(planName, price, duration, settings) {
    const discountPrice = (parseFloat(price) * 0.95).toFixed(2);
    
    return `üíé *PLANO ${planName.toUpperCase()} SELECIONADO!*

üì¶ *DETALHES DO PLANO:*
üìÖ Dura√ß√£o: ${duration}
üì∫ 2000+ canais HD/4K/8K
üì± 5 dispositivos simult√¢neos
üåç Conte√∫do nacional + internacional
üé¨ Filmes, s√©ries e document√°rios
‚öΩ Esportes Premium + PPV

üí∞ *VALORES:*
üí≥ Cart√£o/Boleto: R$ ${price}
üî• PIX (5% OFF): R$ ${discountPrice}

üí≥ *DADOS PARA PAGAMENTO PIX:*
üîë *Chave PIX:* ${settings.pix_key}
üë§ *Nome:* ${settings.pix_name || 'IPTV Premium'}
üí∞ *Valor com desconto:* R$ ${discountPrice}

üìã *COMO PROCEDER:*
1Ô∏è‚É£ Fa√ßa o PIX no valor com desconto
2Ô∏è‚É£ **ENVIE O COMPROVANTE AQUI NO CHAT**
3Ô∏è‚É£ Aguarde aprova√ß√£o (at√© 30 minutos)
4Ô∏è‚É£ Receba login e senha automaticamente

‚ö° **IMPORTANTE:** Envie uma foto ou print do comprovante na pr√≥xima mensagem!

üè† Digite *MENU* para cancelar`;
  }

  /**
   * Gerar dados de pagamento para renova√ß√£o
   */
  generateRenewalPaymentData(plano, valor, duracao, settings) {
    const discountPrice = (parseFloat(valor) * 0.95).toFixed(2);
    
    return `üîÑ *DADOS PARA RENOVA√á√ÉO*

üìÖ *Plano:* ${plano} (${duracao})
üí∞ *Valor com PIX:* R$ ${discountPrice}

üí≥ *DADOS PARA PAGAMENTO PIX:*
üîë *Chave PIX:* ${settings.pix_key}
üë§ *Nome:* ${settings.pix_name || 'IPTV Premium'}
üí∞ *Valor:* R$ ${discountPrice}

üìã *PR√ìXIMOS PASSOS:*
1Ô∏è‚É£ Fa√ßa o PIX no valor acima
2Ô∏è‚É£ **ENVIE O COMPROVANTE AQUI NO CHAT**
3Ô∏è‚É£ Aguarde aprova√ß√£o (at√© 30 minutos)
4Ô∏è‚É£ Sua conta ser√° renovada automaticamente

‚ö° **IMPORTANTE:** Envie uma foto ou print do comprovante na pr√≥xima mensagem!

üè† Digite *MENU* para cancelar`;
  }

  // M√©todo para notificar usu√°rio sobre aprova√ß√£o de teste
  async notifyTestApproved(phone, login, password, expiresAt) {
    const settings = await this.getSettings();
    const expiryTime = moment(expiresAt).format('DD/MM/YYYY HH:mm');
    
    const message = `üéâ *TESTE APROVADO E LIBERADO!* üéâ

üì° *SEUS DADOS DE ACESSO:*
üåê *URL:* ${settings.iptv_server_url}
üë§ *Usu√°rio:* ${login}
üîê *Senha:* ${password}
‚è∞ *V√°lido at√©:* ${expiryTime}

üì≤ *APPS RECOMENDADOS:*
‚Ä¢ üì± Android: IPTV Smarters Pro
‚Ä¢ üçé iPhone: GSE Smart IPTV
‚Ä¢ üì∫ Smart TV: Smart IPTV
‚Ä¢ üíª PC: VLC Player

üìã *COMO USAR:*
1Ô∏è‚É£ Baixe o app recomendado
2Ô∏è‚É£ Adicione nova conex√£o/playlist
3Ô∏è‚É£ Cole os dados acima
4Ô∏è‚É£ Aproveite seu teste!

‚ú® *Gostou?* Digite *2* para ver nossos planos!
üè† Digite *MENU* para voltar ao in√≠cio`;

    await this.sendMessage(phone, message);
  }

  // M√©todo para notificar usu√°rio sobre aprova√ß√£o de plano
  async notifyPlanApproved(phone, login, password, plan, expiresAt) {
    const settings = await this.getSettings();
    const expiryTime = moment(expiresAt).format('DD/MM/YYYY HH:mm');
    
    const message = `üéâ *PLANO APROVADO E ATIVADO!* üéâ

üì¶ *PLANO:* ${plan}
‚è∞ *V√°lido at√©:* ${expiryTime}

üì° *SEUS DADOS DE ACESSO:*
üåê *URL:* ${settings.iptv_server_url}
üë§ *Usu√°rio:* ${login}
üîê *Senha:* ${password}

üì∫ *APROVEITE:*
‚úÖ 2000+ canais HD/4K/8K
‚úÖ 5 dispositivos simult√¢neos
‚úÖ Filmes, s√©ries e document√°rios
‚úÖ Esportes Premium + PPV

üì≤ *BAIXE O APLICATIVO:*
‚Ä¢ üì± Android: IPTV Smarters Pro
‚Ä¢ üçé iPhone: GSE Smart IPTV
‚Ä¢ üì∫ Smart TV: Smart IPTV

üéä *PARAB√âNS!* Sua assinatura est√° ativa!
üè† Digite *MENU* se precisar de ajuda`;

    await this.sendMessage(phone, message);
  }

  // M√©todo para notificar usu√°rio sobre aprova√ß√£o de renova√ß√£o
  async notifyRenewalApproved(phone, login, plan, expiresAt) {
    const expiryTime = moment(expiresAt).format('DD/MM/YYYY HH:mm');
    
    const message = `üîÑ *RENOVA√á√ÉO APROVADA!* üîÑ

üë§ *Login:* ${login}
üìÖ *Plano:* ${plan}
‚è∞ *V√°lida at√©:* ${expiryTime}

‚úÖ *RENOVA√á√ÉO CONCLU√çDA COM SUCESSO!*

Sua conta foi renovada e permanece ativa sem interrup√ß√µes.
Continue aproveitando todo o conte√∫do IPTV Premium!

üì∫ Mais de 2000 canais dispon√≠veis
üé¨ Filmes, s√©ries e document√°rios
‚öΩ Esportes Premium + PPV

üè† Digite *MENU* se precisar de ajuda`;

    await this.sendMessage(phone, message);
  }

  // Mensagens do sistema (outros m√©todos permanecem iguais)
  getWelcomeMessage() {
    return `üì∫ *IPTV PREMIUM* - Bem-vindo! üì∫

üèÜ *Mais de 2000 canais em HD/4K*
‚ö° *Melhor qualidade do Brasil*
üí∞ *Pre√ßos imbat√≠veis*

üìã *MENU PRINCIPAL:*
1Ô∏è‚É£ üéØ Teste Gr√°tis (6h)
2Ô∏è‚É£ üíé Ver Planos e Pre√ßos  
3Ô∏è‚É£ üîÑ Renovar Assinatura
4Ô∏è‚É£ üõ†Ô∏è Suporte T√©cnico
5Ô∏è‚É£ üë• Falar com Atendente

üëÜ *Digite o n√∫mero da op√ß√£o desejada!*`;
  }

  handleTestRequest() {
    return `üéØ *TESTE GR√ÅTIS - 6 HORAS*\n\nüÜì *Totalmente gratuito e sem compromisso!*\n\nüìã Para liberar seu teste, preciso de alguns dados:\n\nüë§ Digite seu *nome completo*:\n\n_Digite MENU a qualquer momento para voltar_`;
  }

  async showPlans() {
    const settings = await this.getSettings();
    
    return `üíé *NOSSOS PLANOS IPTV* üì∫

üéØ *TODOS OS PLANOS INCLUEM:*
üì∫ 2000+ canais HD/4K/8K
üì± 5 dispositivos simult√¢neos
üåç Canais nacionais e internacionais
üé¨ Filmes, s√©ries e document√°rios
‚öΩ Esportes Premium + PPV
üîû Conte√∫do adulto liberado
üë®‚Äçüíª Suporte t√©cnico 24h
üì∂ Instala√ß√£o r√°pida
üö´ Sem travamentos

üí∞ *ESCOLHA SEU PER√çODO:*

üìÖ *MENSAL* - R$ ${settings.monthly_plan_price}
üí≥ Renova√ß√£o mensal
üîÑ Cancelamento livre

üìä *TRIMESTRAL* - R$ ${settings.quarterly_plan_price} ‚≠ê *POPULAR*
üí∞ 3 meses por R$ ${settings.quarterly_plan_price}
üìâ Economia de R$ ${(parseFloat(settings.monthly_plan_price) * 3 - parseFloat(settings.quarterly_plan_price)).toFixed(2)}

üìà *SEMESTRAL* - R$ ${settings.semiannual_plan_price} üíé *ECON√îMICO*
üí∞ 6 meses por R$ ${settings.semiannual_plan_price}
üìâ Economia de R$ ${(parseFloat(settings.monthly_plan_price) * 6 - parseFloat(settings.semiannual_plan_price)).toFixed(2)}

üèÜ *ANUAL* - R$ ${settings.annual_plan_price} üî• *MELHOR CUSTO*
üí∞ 12 meses por R$ ${settings.annual_plan_price}
üìâ Economia de R$ ${(parseFloat(settings.monthly_plan_price) * 12 - parseFloat(settings.annual_plan_price)).toFixed(2)}

üí≥ *FORMAS DE PAGAMENTO:*
üî• PIX (5% desconto adicional)
üí≥ Cart√£o/Boleto

Para contratar, digite: *1*, *2*, *3* ou *4*
üè† Digite *MENU* para voltar`;
  }

  handleRenewal() {
    return `üîÑ *RENOVA√á√ÉO DE ASSINATURA*

Para renovar sua assinatura existente, preciso do seu login atual.

üë§ Digite seu *login/usu√°rio*:

_Digite MENU para voltar ao in√≠cio_`;
  }

  // Fluxo de teste - Nome e Cidade (mantidos iguais)
  async handleTestName(message, user) {
    const msg = message.toLowerCase().trim();
    
    if (msg === 'menu' || msg === 'voltar') {
      user.current_state = this.USER_STATES.MENU_PRINCIPAL;
      this.clearTempData(user.phone);
      return this.getWelcomeMessage();
    }
    
    const name = message.trim();
    if (name.length < 2) {
      return `‚ùå Nome muito curto. Digite seu nome completo:`;
    }
    
    this.setTempData(user.phone, 'name', name);
    await database.run('UPDATE users SET name = ? WHERE id = ?', [name, user.id]);
    user.current_state = this.USER_STATES.TESTE_CIDADE;
    
    return `‚úÖ Nome registrado: *${name}*\n\nüìç Agora informe sua cidade:\n\n_Digite MENU para voltar_`;
  }

  async handleTestCity(message, user) {
    const msg = message.toLowerCase().trim();
    
    if (msg === 'menu' || msg === 'voltar') {
      user.current_state = this.USER_STATES.MENU_PRINCIPAL;
      this.clearTempData(user.phone);
      return this.getWelcomeMessage();
    }
    
    const city = message.trim();
    if (city.length < 2) {
      return `‚ùå Cidade muito curta. Digite sua cidade:`;
    }
    
    this.setTempData(user.phone, 'city', city);
    await database.run('UPDATE users SET city = ? WHERE id = ?', [city, user.id]);
    user.current_state = this.USER_STATES.TESTE_DISPOSITIVO;
    
    return `‚úÖ Cidade registrada: *${city}*\n\nüì± Qual dispositivo voc√™ vai usar?\n\n1Ô∏è‚É£ Celular Android\n2Ô∏è‚É£ Celular iPhone\n3Ô∏è‚É£ Smart TV Samsung/LG\n4Ô∏è‚É£ TV Box Android\n5Ô∏è‚É£ Computador/Notebook\n6Ô∏è‚É£ Outro\n\nDigite o n√∫mero ou nome:\n\n_Digite MENU para voltar_`;
  }

  async handleRenewalLogin(message, user) {
    const msg = message.toLowerCase().trim();
    
    if (msg === 'menu' || msg === 'voltar') {
      user.current_state = this.USER_STATES.MENU_PRINCIPAL;
      this.clearTempData(user.phone);
      return this.getWelcomeMessage();
    }
    
    const login = message.trim();
    if (login.length < 3) {
      return `‚ùå Login muito curto. Digite seu login atual:\n\n_Digite MENU para voltar_`;
    }
    
    this.setTempData(user.phone, 'renewalLogin', login);
    user.current_state = this.USER_STATES.RENOVACAO_PLANO;
    
    const settings = await this.getSettings();
    return `‚úÖ Login registrado: *${login}*\n\nüíé Qual per√≠odo deseja renovar?\n\n1Ô∏è‚É£ Mensal - R$ ${settings.monthly_plan_price}\n2Ô∏è‚É£ Trimestral - R$ ${settings.quarterly_plan_price}\n3Ô∏è‚É£ Semestral - R$ ${settings.semiannual_plan_price}\n4Ô∏è‚É£ Anual - R$ ${settings.annual_plan_price}\n\nDigite o n√∫mero:\n\n_Digite MENU para voltar_`;
  }

  // Outros m√©todos auxiliares (mantidos iguais)
  handleSupport() {
    return `üõ†Ô∏è *SUPORTE T√âCNICO IPTV*

üîç *PROBLEMAS MAIS COMUNS:*

üì± *Travando/Lento:*
‚Ä¢ Verifique internet (m√≠n 10MB)
‚Ä¢ Feche outros apps
‚Ä¢ Reinicie o aplicativo

üì∫ *N√£o conecta:*
‚Ä¢ Confira login e senha
‚Ä¢ Teste outro servidor
‚Ä¢ Reinstale o app

üí¨ *DESCREVA SEU PROBLEMA:*
Digite detalhes do que est√° acontecendo...

üö® Ou digite *ATENDENTE* para suporte humano
üè† Digite *MENU* para voltar`;
  }

  async handleSupportProblem(message, user) {
    const msg = message.toLowerCase().trim();
    
    if (msg.includes('atendente') || msg === 'atendente') {
      user.current_state = this.USER_STATES.AGUARDANDO_ATENDENTE;
      await telegramAdmin.notifyHumanRequest(user.phone, message);
      return this.handleHuman();
    }
    
    if (msg === 'menu' || msg === 'voltar') {
      user.current_state = this.USER_STATES.MENU_PRINCIPAL;
      return this.getWelcomeMessage();
    }
    
    await database.run(
      'INSERT INTO support_requests (user_id, phone, problem_description) VALUES (?, ?, ?)',
      [user.id, user.phone, message]
    );
    
    await telegramAdmin.notifySupportRequest(user.phone, message);
    
    user.current_state = this.USER_STATES.MENU_PRINCIPAL;
    
    return `üõ†Ô∏è *PROBLEMA REGISTRADO!*\n\nSua solicita√ß√£o foi registrada:\n"${message}"\n\nüë®‚Äçüíª Nossa equipe t√©cnica analisar√° seu caso e retornar√° em breve.\n\nüì± Para urg√™ncias, digite *5* para falar com atendente.\n\nüè† Digite *MENU* para voltar`;
  }

  handleHuman() {
    return `üë• *ATENDIMENTO HUMANO*

üîÑ Voc√™ ser√° transferido para nosso suporte especializado.

‚è∞ *HOR√ÅRIOS DE ATENDIMENTO:*
üïê Segunda √† Sexta: 8h √†s 18h
üïê S√°bado: 8h √†s 12h  
üïê Domingo: Emerg√™ncias apenas

üë®‚Äçüíª *STATUS:* Aguardando atendente...
‚è±Ô∏è *Tempo m√©dio:* 5-10 minutos

üí¨ *ENVIE SUA D√öVIDA:*
Descreva seu problema que nosso atendente responder√° em breve.

üè† Digite *MENU* para voltar ao in√≠cio`;
  }

  async handleWaitingHuman(message, user) {
    const msg = message.toLowerCase().trim();
    
    if (msg === 'menu' || msg === 'voltar') {
      user.current_state = this.USER_STATES.MENU_PRINCIPAL;
      return this.getWelcomeMessage();
    }
    
    await telegramAdmin.notifyHumanRequest(user.phone, message);
    
    return `‚è≥ *VOC√ä EST√Å NA FILA DE ATENDIMENTO*\n\nSua mensagem foi registrada:\n"${message}"\n\nüïê Tempo m√©dio de espera: 5-10 minutos\nüë®‚Äçüíª Um atendente entrar√° em contato em breve\n\nüè† Digite *MENU* para voltar ao in√≠cio`;
  }

  // Gerenciamento de dados tempor√°rios (mantidos iguais)
  initTempData(phone) {
    this.userTempData.set(phone, {});
  }

  setTempData(phone, key, value) {
    if (!this.userTempData.has(phone)) {
      this.userTempData.set(phone, {});
    }
    const data = this.userTempData.get(phone);
    data[key] = value;
    this.userTempData.set(phone, data);
  }

  getTempData(phone) {
    return this.userTempData.get(phone) || {};
  }

  clearTempData(phone) {
    this.userTempData.delete(phone);
  }

  // Fun√ß√µes de banco de dados (mantidas iguais)
  async getOrCreateUser(phone) {
    let user = await database.get('SELECT * FROM users WHERE phone = ?', [phone]);
    
    if (!user) {
      const result = await database.run(
        'INSERT INTO users (phone, current_state, message_count) VALUES (?, ?, ?)',
        [phone, this.USER_STATES.MENU_PRINCIPAL, 0]
      );
      
      user = {
        id: result.id,
        phone: phone,
        name: null,
        city: null,
        device: null,
        current_state: this.USER_STATES.MENU_PRINCIPAL,
        message_count: 0,
        created_at: new Date().toISOString(),
        last_interaction: new Date().toISOString()
      };
    }
    
    return user;
  }

  async updateUserInteraction(userId, newState) {
    await database.run(
      'UPDATE users SET current_state = ?, message_count = message_count + 1, last_interaction = CURRENT_TIMESTAMP WHERE id = ?',
      [newState, userId]
    );
  }

  async logMessage(userId, phone, content, type) {
    await database.run(
      'INSERT INTO messages (user_id, phone, message_content, message_type) VALUES (?, ?, ?, ?)',
      [userId, phone, content, type]
    );
  }

  async getSettings() {
    const settings = await database.all('SELECT key_name, key_value FROM settings');
    const result = {};
    settings.forEach(setting => {
      result[setting.key_name] = setting.key_value;
    });
    return result;
  }

  async sendMessage(phone, message, instance = null) {
    try {
      const instanceToUse = instance || this.instanceName;
      const url = `${this.evolutionApiUrl}/message/sendText/${instanceToUse}`;
      
      const payload = { 
        number: phone, 
        text: message,
        delay: 1200,           // LINHA ADICIONADA
        linkPreview: false     // LINHA ADICIONADA
      };
      
      const headers = { 'Content-Type': 'application/json' };
      
      if (this.evolutionApiKey) {
        headers['apikey'] = this.evolutionApiKey;
      }

      console.log(`üì§ Enviando para ${phone} via ${instanceToUse} com delay de 1.2s`);

      const response = await axios.post(url, payload, { 
        headers,
        timeout: 15000        // TIMEOUT AUMENTADO
      });
      
      if (response.data && response.data.key) {
        console.log(`‚úÖ Mensagem enviada para ${phone} - ID: ${response.data.key.id}`);
      }
      
    } catch (error) {
      console.error(`‚ùå Erro ao enviar mensagem para ${phone}:`, error.message);
      if (error.response) {
        console.error('Response error:', error.response.data);
      }
    }
  }

  startCleanupTimer() {
    setInterval(() => {
      this.cleanupTempData();
    }, 60 * 60 * 1000);
  }

  cleanupTempData() {
    const now = Date.now();
    const maxAge = 2 * 60 * 60 * 1000;

    for (const [phone, data] of this.userTempData.entries()) {
      if (data.timestamp && (now - data.timestamp) > maxAge) {
        this.userTempData.delete(phone);
        console.log(`üßπ Dados tempor√°rios limpos para ${phone}`);
      }
    }
    
    console.log(`üßπ Limpeza conclu√≠da. Dados tempor√°rios ativos: ${this.userTempData.size}`);
  }
}

// Inst√¢ncia singleton
const botHandler = new IPTVBot();
botHandler.startCleanupTimer();

module.exports = { botHandler };